--[[ Lua code. See documentation: http://berserk-games.com/knowledgebase/scripting/ --]]
--[[ The onLoad event is called after the game save finishes loading. --]]

--[[ The onUpdate event is called once per frame. --]]
function onUpdate ()
    --[[ print('onUpdate loop!') --]]
end

function createHash()
  local self = {
    hash = 0
  }

  local update = function(string)
    if string != nil then
      for idx = 1, #string do
        self.hash = bit32.bxor(self.hash, bit32.lshift(self.hash, 5) + bit32.rshift(self.hash, 2) + string:byte(idx))
      end
    end
  end

  local result = function()
    return "" .. self.hash
  end

  return {
    update = update,
    result = result
  }
end

function createRecordedModels()
  local self = {
    initialModels = {}, -- List of all GUIDs pressent when the recording started
    initial = true, -- Boolean if recording has started
    models = {},
    clones = {},
    modelIndex = {},
    json = "{}",
    dirty = false
  }

  local getFullSpawnInfo = function(model, modelId) -- private
    return {
      json = model.getJSON(false),
      position = model.getPosition(),
      rotation = model.getRotation(),
      scale = model.getScale(),
      identity = modelId,
      guid = model.guid
    }
  end

  local getCloneSpawnInfo = function(model, cloneOf) -- private
    return {
      cloneOf = cloneOf,
      position = model.getPosition(),
      rotation = model.getRotation(),
      scale = model.getScale()
    }
  end

  local objectIdentity = function(model) -- private
    local hash = createHash()
    hash.update(model.getName())
    hash.update(model.getDescription())
    hash.update(model.getColorTint():toHex(false))
    hash.update(model.getCustomObject()["mesh"])
    for _, child in pairs(model.getAttachments()) do
      hash.update(child["name"])
      hash.update(child["description"])
      -- TODO: Is it possible to access the child mesh? Detach?
    end

    return hash.result()
  end

  local startRecording = function()
    self.initial = false
  end

  local add = function(model)
    self.dirty = true
    local modelId = objectIdentity(model)
    local cloneOf = self.modelIndex[modelId]
    if cloneOf != nil then
      self.clones[model.guid] = getCloneSpawnInfo(model, cloneOf)
    else
      self.modelIndex[modelId] = model.guid
      self.models[model.guid] = getFullSpawnInfo(model, modelId)
    end

    if self.initial then
      table.insert(self.initialModels, model.guid)
    end
  end

  local initialModels = function()
    return self.initialModels
  end

  local getModelJson = function(guid)
    local model = self.models[guid]
    if (model != null) then
      return model
    else
      local clonedModel = self.clones[guid]
      local modelJson = self.models[clonedModel.cloneOf].json
      clonedModel.json = string.gsub(modelJson, clonedModel.cloneOf, guid)
      return clonedModel
    end
  end

  local save = function()
    if self.dirty then
      self.json = JSON.encode({
        initialModels = self.initialModels,
        initial = self.initial,
        models = self.models,
        clones = self.clones
      })
      self.dirty = false
    end

    return self.json
  end

  local load = function(json)
    if json != "" and json != "{}" then
      local decoded = JSON.decode(json)
      self.models = decoded.models
      self.clones = decoded.clones
      self.initialModels = decoded.initialModels
      self.initial = decoded.initial
      self.dirty = false
      self.json = json

      for _, value in pairs(self.models) do
        self.modelIndex[value.identity] = value.guid
      end
    end
  end

  return {
    add = add,
    getModelJson = getModelJson,
    initialModels = initialModels,
    load = load,
    save = save,
    startRecording = startRecording
  }
end

function createActionsList(recordedModels)
  -- action = {
  --   spawn = {
  --     json = object.getObjectJson(),
  --     position = object.getPosition(),
  --     rotation = object.getRotation(),
  --     scale = object.getScale()
  --   }
  --   move = {
  --     position = Table,
  --     rotation = Table
  --   }
  --   destroyed = false
  -- }

  local self = {
    recordedModels = recordedModels,
    actionsSerialized = {},
    actions = {},
    action = {}
  }

  local save = function()
    return "{\"actions\": [" .. table.concat(self.actionsSerialized, ",") .. "], \"action\": " .. JSON.encode(action) .. "}"
  end

  local load = function(json)
    local decoded = JSON.decode(json)
    self.actions = decoded.actions

    if decoded.action != nil then
      self.action = decoded.action
    end

    self.actionsSerialized = {} -- TODO: init only needed if recording in progress
    for _, v in pairs(self.actions) do
      table.insert(self.actionsSerialized, JSON.encode(v))
    end

  end

  local saveAction = function()
    table.insert(self.actions, self.action)
    table.insert(self.actionsSerialized, JSON.encode(self.action))
    self.recordedModels.save()
    self.action = {}
  end

  local recordActionText = function(text)
    self.action.text = text
  end

  local recordMove = function(object)
    if self.action[object.guid] != nil then
      self.action[object.guid].move = {
        position = object.getPosition(),
        rotation = object.getRotation()
      }
    else
      self.action[object.guid] = {
        move = {
          position = object.getPosition(),
          rotation = object.getRotation()
        }
      }
    end
  end

  local recordSpawn = function(object)
    recordedModels.add(object)

    if self.action[object.guid] != nil then
      self.action[object.guid].spawn = object.guid
    else
      self.action[object.guid] = {
        spawn = object.guid
      }
    end
  end

  local recordDelete = function(object)
    if self.action[object.guid] != nil then
      if self.action[object.guid].spawn != nil then -- if the object was spawned during this action
        self.action[object.guid] = nil -- remove the entire action for this model
      else
        self.action[object.guid].destroyed = true
      end
    else
      self.action[object.guid] = {
        destroyed = true
      }
    end
  end

  local getAction = function(actionIndex)
    return self.actions[actionIndex]
  end

  local resetCurrent = function()
    self.action = {}
  end

  return {
    getAction = getAction,
    recordActionText = recordActionText,
    recordMove = recordMove,
    recordSpawn = recordSpawn,
    recordDelete = recordDelete,
    resetCurrent = resetCurrent,
    load = load,
    save = save,
    saveAction = saveAction
  }
end

function onLoad(serializedState)
    self.UI.hide("recordActionPanel")

    -- ZoC variables
    inches = 2.54
    rangeToolRanges = {5, 10, 15, 20, 30, 45, 60, 75, 15, 0}
    elevation = 0.2
    thickness = 0.05

    -- Battle report variables
    recordedModels = createRecordedModels()
    actions = createActionsList(recordedModels)
    recordState = 0
    replayIndex = 1

    if serializedState != "" then
      -- log(serializedState, "Serialized state")
      -- TODO: Use coroutine to load in the background
      local time = os.time()
      -- local start, ending = string.find(serializedState, "([^|@|]+)")
      local substringStart = 0
      local start, ending = string.find(serializedState, "|@|", 0, true)
      local recordedSerialized = string.sub(serializedState, substringStart, start - 1)
      substringStart = ending + 1

      start, ending = string.find(serializedState, "|@|", substringStart, true)
      local actionsSerialized = string.sub(serializedState, substringStart, start - 1)
      substringStart = ending + 1
      --log(actionsSerialized, "actionsSerialized")

      local dynamicSerialized = string.sub(serializedState, substringStart)
      -- log(dynamicSerialized, "dynamicSerialized")

      log(os.time() - time, "Split string")

      recordedModels.load(recordedSerialized)
      log(os.time() - time, "Loaded recorded models")

      actions.load(actionsSerialized)
      log(os.time() - time, "Loaded actions")

      local dynamic = JSON.decode(dynamicSerialized)
      recordState = dynamic.recordState

      log(os.time() - time, "Total load time")
    end

    setupContextMenu()
    addHotkey("Record action", recordAction, false)
    addHotkey("Next action", nextAction, false)
    self.UI.hide("loadingPanel")
end

function onSave()
  local start = os.clock()
  local state = recordedModels.save() .. "|@|" .. actions.save() .. "|@|" .. JSON.encode({ --TODO: pipe is not unique enough, may be in descriptions etc.
    recordState = recordState,
  })
  log(os.clock() - start, "State creation time")
  return state
end

function setupContextMenu()
  clearContextMenu()

  if recordState == 0 then
    addContextMenuItem("+ to recording", tagRecorded)
    addContextMenuItem("- from recorded", removeRecorded)
    addContextMenuItem("Show recorded", flash)
    addContextMenuItem("Start recording", saveInitial)
  elseif recordState == 1 then
    addContextMenuItem("Record action", recordAction)
    addContextMenuItem("End recording", finalizeRecording)
  elseif actions.getAction(replayIndex) == nil then
    addContextMenuItem("Restart replay", toInitial)
    addContextMenuItem("Resume recording", resumeRecording)
  else
    addContextMenuItem("Restart replay", toInitial)
    addContextMenuItem("Show next", nextAction)
  end
end

-- Highlight all recorded models
function flash(player_color, menu_position)
  items = getObjectsWithTag("recorded")
  for k, v in pairs(items) do
    v.highlightOn(player_color, 1)
  end
end

-- add models to the recording
function tagRecorded(player_color, menu_position)
    local selected = Player[player_color].getSelectedObjects()
    for k, v in pairs(selected) do
      v.addTag("recorded")
    end
end

-- remove models from the recording
function removeRecorded(player_color, menu_position)
    local selected = Player[player_color].getSelectedObjects()
    for k, v in pairs(selected) do
      v.removeTag("recorded")
    end
end

-- Save initial state of the recording and info about recorded modes
-- in order to be able to spawn them later
function saveInitial(player_color, menu_position)
  items = getObjectsWithTag("recorded")

  for k, v in pairs(items) do
    recordedModels.add(v)
  end

  recordedModels.startRecording()
  recordedModels.save()
  recordState = 1
  setupContextMenu()
end

-- End the recording
function finalizeRecording()
  recordState = 2
  setupContextMenu()
end

-- Resume the recording
function resumeRecording()
  recordState = 1
  actions.resetCurrent()
  setupContextMenu()
end

-- Init recording of an action, will show UI for action text input
function recordAction(player)
  if recordState == 1 then
    self.UI.setAttribute("recordActionPanel", "visibility", player)
    self.UI.show("recordActionPanel")
  else
    broadcastToColor("Recording has not started", player)
  end
end

-- Called by action input field when edited
function cacheActionText(player, text)
  actions.recordActionText(text)
end

-- User saved action, triggered from UI
function recordActionSave(player)
  actions.saveAction()

  self.UI.hide("recordActionPanel")
  self.UI.setAttribute("recordActionText", "text", "")
end

-- User canceled record action dialog, triggered from UI
function recordActionCancel()
  self.UI.hide("recordActionPanel")
  self.UI.setAttribute("recordActionText", "text", "")
end

-- Move models to starting position and spawn deleted models
function toInitial(player_color, menu_position)
  -- delete all objects
  items = getObjectsWithTag("recorded")
  for k, v in pairs(items) do
    destroyObject(v)
  end

  -- Spawn all initial models
  local initial = recordedModels.initialModels()
  for _, guid in pairs(initial) do
    local json = recordedModels.getModelJson(guid)
    localSpawn(json)
  end

  replayIndex = 1
end

-- Privte helper function: Spawn a model
function localSpawn(description)
  local object = spawnObjectJSON(description)
  object.addTag("recorded")

  return object
end

-- Replay next action
function nextAction(color)
  if recordState != 2 then
    broadcastToColor("Replay not started", color)
    return
  end

  -- remove all models marked as killed in previous action
  deleteDead()
  local action = actions.getAction(replayIndex)

  -- If we reached the end of the replay
  if action == nil then
    broadcastToAll("End of recording")
    setupContextMenu()
    return
  end

  -- Show axtion description as a broadcast
  broadcastToAll(action.text)

  -- Execute all recorded changes for this action
  for guid, v in pairs(action) do
    if k != "text" then
      local item

      -- Spawn the object if it is new for this action
      if v.spawn != nil then
        item = localSpawn(recordedModels.getModelJson(v.spawn))
      else -- or load it by GUID
        item = getObjectFromGUID(guid)
      end

      -- Move it, if moved
      if v.move != nil then
        if v.move.position != nil then
          item.setPositionSmooth(v.move.position, false, false)
        end
        if v.move.rotation != nil then
          item.setRotationSmooth(v.move.rotation, false, false)
        end
      end

      -- Mark it deleted, if destroyed
      if v.destroyed then
        item.highlightOn("Red")
        item.addTag("dead")
      end
    end
  end

  -- Move on to next action
  replayIndex = replayIndex + 1
end

-- Delete all models marked as dead
function deleteDead()
  items = getObjectsWithTag("dead")
  for k, v in pairs(items) do
    destroyObject(v)
  end
end

-- Record deleted models, called by the game
function onObjectDestroy(object)
  if object.hasTag("recorded") and not object.hasTag("dead") and recordState == 1 then
    actions.recordDelete(object)
  end
end

-- Record rotated models, called by the game
function onObjectRotate(object, spin, flip, player_color, old_spin, old_flip)
  if object.hasTag("recorded") and recordState == 1 then
    actions.recordMove(object)
  end
end

-- Record moved models, called by the game
function onObjectDrop(colorName, object)
  if object.hasTag("recorded") and recordState == 1 then
    actions.recordMove(object)
  end
end

-- record the initial position of the model if this was not part of the setup, eg BMs, Daemons, etc... called by the game
function onObjectSpawn(object)
  if object.hasTag("recorded") and recordState == 1 then
    actions.recordSpawn(object)
  end
end


-- Draw ZoC stuff
function onScriptingButtonDown(index, color)
    local player = Player[color]
    local selected = player.getSelectedObjects()
    local range = rangeToolRanges[index]
    if range == 0 then
      print(player.steam_name, " disabled highlight")
    elseif index == 9 then
      print(player.steam_name, " requested objective range highlight")
    else
      print(player.steam_name, " requested ", range, "cm highlight")
    end
    local rangeInCm = range / inches
    for k, v in pairs(selected) do
      if index == 10 then
        v.setVectorLines({})
      elseif  index == 9 then
        v.setVectorLines({
            {
                points    = circleFromCenter(v, rangeInCm),
                color     = stringColorToRGB(color),
                thickness = compensatedThickness(v),
                rotation  = {0, 0, 0},
            }
        })
      elseif hasRectangleBase(v) then
        v.setVectorLines({
            {
                points    = rectangleZoc(v, rangeInCm),
                color     = stringColorToRGB(color),
                thickness = compensatedThickness(v),
                rotation  = {0, 0, 0},
            }
        })
      else
        v.setVectorLines({
            {
                points    = circleZoc(v, rangeInCm),
                color     = stringColorToRGB(color),
                thickness = compensatedThickness(v),
                rotation  = {0, 0, 0},
            }
        })
      end
    end
end

function compensatedThickness(object)
  return (thickness / object.getScale()["x"])
end

function hasRectangleBase(obj)
  local size = obj.getBoundsNormalized()["size"]
  local ratio = math.abs(size[1]/size[3])
  return ratio < 0.95 or ratio > 1.05
end

function circleZoc(obj, radius)
    local size = obj.getBoundsNormalized()["size"]
    local radiusFromCenter = radius + (math.max(size[1], size[3]) / 2)
    local points = {}
    insertCircle(points, obj, radiusFromCenter, elevation)
    insertCircle(points, obj, radiusFromCenter, elevation + 1)
    return points
end

function circleFromCenter(obj, radius)
    local points = {}
    insertCircle(points, obj, radius, elevation)
    insertCircle(points, obj, radius, elevation + 1)
    return points
end

function rectangleZoc(obj, zoc)
  local points = {}
  insertRectangle(points, obj, elevation, zoc)
  insertRectangle(points, obj, elevation + 1, zoc)
  return points
end

function insertRectangle(points, obj, localElevation,  zoc)
  local width = obj.getBoundsNormalized()["size"][1]
  local height = obj.getBoundsNormalized()["size"][3]
  handleRactanglePoint(points, obj, {zoc+(width/2), localElevation, -height/2})
  for i=0,9 do
      handleRactanglePoint(points, obj, {(width/2) + math.cos(math.rad(i*10)) * zoc, localElevation, (height/2) + math.sin(math.rad(i*10)) * zoc})
  end
  for i=10,18 do
      handleRactanglePoint(points, obj, {(-width/2) + math.cos(math.rad(i*10)) * zoc, localElevation, (height/2) + math.sin(math.rad(i*10)) * zoc})
  end
  for i=19,27 do
      handleRactanglePoint(points, obj, {(-width/2) + math.cos(math.rad(i*10)) * zoc, localElevation, (-height/2) + math.sin(math.rad(i*10)) * zoc})
  end
  for i=28,36 do
      handleRactanglePoint(points, obj, {(width/2) + math.cos(math.rad(i*10)) * zoc, localElevation, (-height/2) + math.sin(math.rad(i*10)) * zoc})
  end
end

function insertCircle(points, object, radius, localElevation)
  for i = 0,36 do
    table.insert(points, globalToLocal(object, {
      (math.cos(math.rad(i*10)) * radius),
      localElevation,
      (math.sin(math.rad(i*10)) * radius)
    }))
  end
end

function handleRactanglePoint(result, object, point)
  local rotated = rotateRoundY(math.rad(-object.getRotation().y + 360), point)
  table.insert(result, globalToLocal(object, rotated))
end

function rotateRoundY(angle, point)
  return {
    point[1] * math.cos(angle) - point[3] * math.sin(angle),
    point[2],
    point[1] * math.sin(angle) + point[3] * math.cos(angle)
  }
end

function globalToLocal(object, coordinates)
  return object.positionToLocal({
    coordinates[1] + object.getPosition().x,
    coordinates[2] + object.getPosition().y,
    coordinates[3] + object.getPosition().z
  })
end
